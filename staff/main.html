<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Score Main v26</title>
  <style>
    body { font-family: sans-serif; margin: 20px; }

    #players {
      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
      gap: 10px;
    }

    .player {
      border: 1px solid #ccc;
      padding: 10px;
      border-radius: 10px;
      background: #fafafa;
      width: 9vw;
      height: 300px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }
    .player.out { opacity: 0.4; background: #eee; }

    .player-name {
      writing-mode: vertical-rl;
      text-orientation: upright;
      font-weight: 900;
      line-height: 1.1;
      height: 180px;
      width: 40px;
      white-space: nowrap;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 36px;
      transform-origin: center center;
    }

    .player-status {
      font-size: 18px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .player-scoreline {
      font-size: 28px;
      font-weight: bold;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .player-score-total { color: red; }
    .player-score-dash  { color: black; }
    .player-score-wrong { color: blue; }

    #gaugeWrapper {
      position: relative;
      width: 100%;
      margin-top: 120px;
      margin-bottom: 20px;
    }

    #gaugeContainer {
      width: 100%;
      height: 20px;
      background: #ddd;
      border-radius: 10px;
      position: relative;
    }

    #gaugeBar {
      height: 100%;
      width: 0%;
      background: #4caf50;
      border-radius: 10px;
      transition: width 0.3s;
    }

    .gaugeTick {
      position: absolute;
      top: -4px;
      width: 4px;
      height: 28px;
      background: #333;
      border-radius: 2px;
    }

    #gaugeIcon {
      position: absolute;
      top: -110px;
      width: 98px;
      height: auto;
      transition: transform 0.3s;
      pointer-events: none;
      display: none;
    }
  </style>
</head>

<body>

<h2>Score Main v26</h2>

<!-- 問題数表示 -->
<h3 id="problemCountDisplay">問題数: 0</h3>

<!-- ゲージ -->
<div id="gaugeWrapper">
  <img id="gaugeIcon" src="assets/images/tokuten/kyot10l.png">
  <div id="gaugeContainer">
    <div id="gaugeBar"></div>
  </div>
</div>

<!-- 現在の設定表示 -->
<div id="currentSettings" style="
  border:1px solid #ccc;
  padding:10px;
  margin-bottom:20px;
  background:#f7f7f7;
  width:300px;
">
  <div>ルール：<span id="cs_rule">---</span></div>
  <div>限定問題数：<span id="cs_max">---</span></div>
  <div>現在：<span id="cs_now">0</span> 問</div>
</div>

<!-- プレイヤー一覧 -->
<div id="players"></div>

<!-- 設定画面・リセット -->
<div style="margin-top:20px; display:flex; gap:10px; align-items:center;">
  <a href="settings.html">設定画面へ</a>
  <button onclick="resetAll()">リセット</button>
</div>

<script>
  /* ====== データ（settings.html から localStorage で受け取る） ====== */
  let players      = JSON.parse(localStorage.getItem("players")      || "[]");
  let scoreItems   = JSON.parse(localStorage.getItem("scoreItems")   || "[]");
  let logs         = JSON.parse(localStorage.getItem("logs")         || "[]");
  let problemCount = Number(localStorage.getItem("problemCount")     || 0);
  let maxProblems  = Number(localStorage.getItem("maxProblems")      || 0);
  let finished     = false;
  let history      = [];

  function getPreset() {
    return localStorage.getItem("currentRule") || "";
  }

  /* ====== ゲージ描画 ====== */
  function drawGaugeTicks() {
    const container = document.getElementById("gaugeContainer");
    container.querySelectorAll(".gaugeTick").forEach(e => e.remove());

    if (!maxProblems) return;

    for (let i = 5; i <= maxProblems; i += 5) {
      const tick = document.createElement("div");
      tick.className = "gaugeTick";
      const ratio = i / maxProblems;
      tick.style.left = `calc(${ratio * 100}% - 2px)`;
      container.appendChild(tick);
    }
  }

  function updateGauge() {
    if (!maxProblems) {
      const bar = document.getElementById("gaugeBar");
      bar.style.width = "0%";
      const icon = document.getElementById("gaugeIcon");
      icon.style.display = "none";
      return;
    }

    const ratio = Math.min(problemCount / maxProblems, 1);
    const bar = document.getElementById("gaugeBar");
    bar.style.width = (ratio * 100) + "%";

    const icon = document.getElementById("gaugeIcon");
    const containerWidth = document.getElementById("gaugeContainer").offsetWidth;
    const iconWidth = icon.offsetWidth;

    if (problemCount === 0) {
      icon.style.display = "none";
      return;
    } else {
      icon.style.display = "block";
    }

    const x = ratio * containerWidth - iconWidth;
    icon.style.transform = `translateX(${x}px)`;
  }

  /* ====== プレイヤー描画 ====== */
  function adjustNameSize(nameDiv) {
    const maxHeight = 180;
    nameDiv.style.transform = "scaleY(1)";
    const actual = nameDiv.scrollHeight;

    if (actual > maxHeight) {
      const scale = (maxHeight / actual) * 0.85;
      nameDiv.style.transform = `scaleY(${scale})`;
    }
  }

  function calcTotal(player) {
    let total = 0;
    scoreItems.forEach(item => {
      const v = player.scores[item.name];
      const safe = Number.isFinite(v) ? v : 0;
      total += safe * item.weight;
    });
    return total;
  }

  function render() {
    const container = document.getElementById("players");
    container.innerHTML = "";

    players.forEach((p) => {
      const div = document.createElement("div");
      div.className = "player";
      if (p.status === "out") div.classList.add("out");

      const nameDiv = document.createElement("div");
      nameDiv.className = "player-name";
      nameDiv.textContent = p.name;
      div.appendChild(nameDiv);
      requestAnimationFrame(() => adjustNameSize(nameDiv));

      const statusDiv = document.createElement("div");
      statusDiv.className = "player-status";
      if (getPreset() === "freeze" && p.freezeStop > 0) {
        statusDiv.textContent = `Stop ${p.freezeStop}`;
      } else if (p.status === "out") {
        statusDiv.textContent = "脱落";
      } else {
        statusDiv.textContent = "";
      }
      div.appendChild(statusDiv);

      const scoreLine = document.createElement("div");
      scoreLine.className = "player-scoreline";

      const total = calcTotal(p);
      const wrong = Number.isFinite(p.scores["誤答"]) ? p.scores["誤答"] : 0;

      scoreLine.innerHTML = `
        <span class="player-score-total">${total}</span>
        <span class="player-score-dash"> - </span>
        <span class="player-score-wrong">${wrong}</span>
      `;
      div.appendChild(scoreLine);

      container.appendChild(div);
    });

    document.getElementById("problemCountDisplay").textContent =
      `問題数: ${problemCount}`;
  }

  /* 現在の設定表示 */
  function updateCurrentSettings() {
    const rule = getPreset() || "---";
    const max  = localStorage.getItem("maxProblems")  || "---";
    const now  = localStorage.getItem("problemCount") || 0;

    document.getElementById("cs_rule").textContent = rule;
    document.getElementById("cs_max").textContent  = max;
    document.getElementById("cs_now").textContent  = now;
  }

  /* Freeze 減衰 / 終了判定 */
  function applyFreezeDecay() {
    if (getPreset() !== "freeze") return;
    players.forEach(p => {
      if (p.freezeStop > 0) p.freezeStop--;
    });
  }

  function checkFinish() {
    if (maxProblems && problemCount >= maxProblems) {
      finished = true;
      logs.push(`${new Date().toLocaleTimeString()} ★終了★`);
    }
  }

  /* ====== スコア処理 ====== */
  function changeScore(playerIndex, itemName, delta) {
    if (finished) return;

    const p = players[playerIndex];
    const preset = getPreset();

    if (typeof p.scores[itemName] !== "number") {
      p.scores[itemName] = 0;
    }

    const prevData = {
      type: "score",
      playerIndex,
      itemName,
      delta: -delta,
      problemDelta: -1,
      prevStatus: p.status,
      prevScores: JSON.parse(JSON.stringify(p.scores)),
      prevFreeze: p.freezeStop
    };

    let skipFreezeDecay = false;

    logs.push(`${new Date().toLocaleTimeString()} ${p.name} ${itemName} +1`);

    p.scores[itemName] += delta;

    if (preset === "updown" && itemName === "誤答") {
      if (p.scores["誤答"] === 1) {
        if (typeof p.scores["正解"] !== "number") p.scores["正解"] = 0;
        p.scores["正解"] = 0;
      }
      if (p.scores["誤答"] === 2) {
        p.status = "out";
      }
    }

    if (preset === "freeze" && itemName === "誤答") {
      p.freezeStop = p.scores["誤答"];
      skipFreezeDecay = true;
    }

    history.push(prevData);

    problemCount++;
    if (!skipFreezeDecay) {
      applyFreezeDecay();
    }
    updateGauge();
    checkFinish();
    render();

    localStorage.setItem("players", JSON.stringify(players));
    localStorage.setItem("problemCount", problemCount);
    localStorage.setItem("logs", JSON.stringify(logs));
    updateCurrentSettings();
  }

  function noAnswer() {
    if (finished) return;

    history.push({
      type: "noAnswer",
      problemDelta: -1,
      prevFreeze: players.map(p => p.freezeStop)
    });

    logs.push(`${new Date().toLocaleTimeString()} スルー（無回答）`);

    problemCount++;
    applyFreezeDecay();
    updateGauge();
    checkFinish();
    render();

    localStorage.setItem("problemCount", problemCount);
    localStorage.setItem("logs", JSON.stringify(logs));
    updateCurrentSettings();
  }

  function undo() {
    const last = history.pop();
    if (!last) return;

    if (last.type === "score") {
      const p = players[last.playerIndex];
      p.scores = last.prevScores;
      p.status = last.prevStatus;
      p.freezeStop = last.prevFreeze;

      logs.push(`${new Date().toLocaleTimeString()} Undo: ${p.name} ${last.itemName}`);
    }

    if (last.type === "noAnswer") {
      logs.push(`${new Date().toLocaleTimeString()} Undo: スルー取消`);
      players.forEach((p, i) => {
        p.freezeStop = last.prevFreeze[i];
      });
    }

    if (last.problemDelta) {
      problemCount += last.problemDelta;
    }

    finished = false;
    updateGauge();
    render();

    localStorage.setItem("players", JSON.stringify(players));
    localStorage.setItem("problemCount", problemCount);
    localStorage.setItem("logs", JSON.stringify(logs));
    updateCurrentSettings();
  }

  /* ★ 全体リセット ★ */
  function resetAll() {
    const ok = window.confirm(
      "スコア・状態・Stop・問題数・ログをすべてリセットします。\nよろしいですか？"
    );
    if (!ok) return;

    players.forEach(p => {
      p.scores = {};
      p.status = "alive";
      p.freezeStop = 0;
    });

    history = [];
    logs = [];
    problemCount = 0;
    finished = false;

    localStorage.setItem("players", JSON.stringify(players));
    localStorage.setItem("problemCount", problemCount);
    localStorage.setItem("logs", JSON.stringify(logs));

    updateGauge();
    render();
    updateCurrentSettings();
  }

  /* ====== キーボード操作 ====== */
  document.addEventListener("keydown", (e) => {
    if (finished) return;

    const code = e.code;
    const isNumpad = code.startsWith("Numpad");

    if (isNumpad) {
      e.preventDefault();

      let index = null;
      if (code === "Numpad0") index = 9;
      else {
        const num = Number(code.replace("Numpad", ""));
        if (num >= 1 && num <= 9) index = num - 1;
      }

      if (index !== null && index < players.length) {
        const p = players[index];
        if (p.status !== "out" && p.freezeStop === 0) {
          if (e.ctrlKey) changeScore(index, "誤答", +1);
          else changeScore(index, "正解", +1);
        }
      }
      return;
    }

    if (e.code === "Insert") {
      e.preventDefault();
      noAnswer();
      return;
    }

    if (e.code === "Delete") {
      e.preventDefault();
      undo();
      return;
    }
  });

  /* localStorage 変更監視（settings → main） */
  window.addEventListener("storage", () => {
    players      = JSON.parse(localStorage.getItem("players")      || "[]");
    scoreItems   = JSON.parse(localStorage.getItem("scoreItems")   || "[]");
    logs         = JSON.parse(localStorage.getItem("logs")         || "[]");
    problemCount = Number(localStorage.getItem("problemCount")     || 0);
    maxProblems  = Number(localStorage.getItem("maxProblems")      || 0);
    finished     = false;

    drawGaugeTicks();
    updateGauge();
    render();
    updateCurrentSettings();
  });

  /* 初期描画 */
  drawGaugeTicks();
  updateGauge();
  render();
  updateCurrentSettings();
</script>

</body>
</html>
