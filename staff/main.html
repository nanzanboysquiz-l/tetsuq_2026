<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Score Main v30.1</title>
  <style>
    body { font-family: sans-serif; margin: 20px; }

    #players {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .player {
      border: 1px solid #ccc;
      padding: 10px;
      border-radius: 10px;
      background: #fafafa;
      width: 9vw;
      height: 300px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }
    .player.out { opacity: 0.4; background: #eee; }

    .player-name {
      writing-mode: vertical-rl;
      text-orientation: upright;
      font-weight: 900;
      height: 180px;
      width: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 36px;
      transform-origin: center center;
      white-space: nowrap;
    }

    .player-status {
      font-size: 18px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .player-scoreline {
      font-size: 28px;
      font-weight: bold;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .player-score-total { color: red; }
    .player-score-dash  { color: black; }
    .player-score-wrong { color: blue; }

    #gaugeWrapper {
      position: relative;
      width: 100%;
      margin-top: 120px;
      margin-bottom: 20px;
    }

    #gaugeContainer {
      width: 100%;
      height: 20px;
      background: #ddd;
      border-radius: 10px;
      position: relative;
    }

    #gaugeBar {
      height: 100%;
      width: 0%;
      background: #4caf50;
      border-radius: 10px;
      transition: width 0.3s;
    }

    .gaugeTick {
      position: absolute;
      top: -4px;
      width: 4px;
      height: 28px;
      background: #333;
      border-radius: 2px;
    }

    #gaugeIcon {
      position: absolute;
      top: -110px;
      width: 98px;
      pointer-events: none;
      display: none;
      transition: transform 0.3s;
    }

    #winMode {
      color: red;
      font-weight: bold;
      font-size: 20px;
      margin-bottom: 10px;
    }
  </style>
</head>

<body>

<h2>Score Main v29</h2>

<h3 id="problemCountDisplay">問題数: 0</h3>
<div id="winMode"></div>

<div id="gaugeWrapper">
  <img id="gaugeIcon" src="assets/images/tokuten/kyot10l.png">
  <div id="gaugeContainer">
    <div id="gaugeBar"></div>
  </div>
</div>

<div id="currentSettings" style="
  border:1px solid #ccc;
  padding:10px;
  margin-bottom:20px;
  background:#f7f7f7;
  width:300px;
">
  <div>ルール：<span id="cs_rule">---</span></div>
  <div>限定問題数：<span id="cs_max">---</span></div>
  <div>現在：<span id="cs_now">0</span> 問</div>
  <div>勝ち抜け点：<span id="cs_winScore">---</span></div>
  <div>勝ち抜け人数：<span id="cs_winCount">---</span></div>
  <div>脱落誤答数：<span id="cs_loseWrong">---</span></div>
</div>

<div id="players"></div>

<div style="margin-top:20px; display:flex; gap:10px;">
  <a href="settings.html">設定画面へ</a>
  <button onclick="resetAll()">リセット</button>
</div>

<script>
/* ====== データ読み込み ====== */
let players      = JSON.parse(localStorage.getItem("players")      || "[]");
let scoreItems   = JSON.parse(localStorage.getItem("scoreItems")   || "[]");
let logs         = JSON.parse(localStorage.getItem("logs")         || "[]");
let problemCount = Number(localStorage.getItem("problemCount")     || 0);
let maxProblems  = Number(localStorage.getItem("maxProblems")      || 0);
let finished     = false;
let history      = [];

let winScore  = Number(localStorage.getItem("winScore")  || 0);
let winCount  = Number(localStorage.getItem("winCount")  || 0);
let loseWrong = Number(localStorage.getItem("loseWrong") || 0);

let winners = JSON.parse(localStorage.getItem("winners") || "[]");
let winSettingMode = false;

function getPreset() {
  return localStorage.getItem("currentRule") || "";
}

/* ====== ゲージ ====== */
function drawGaugeTicks() {
  const container = document.getElementById("gaugeContainer");
  container.querySelectorAll(".gaugeTick").forEach(e => e.remove());

  if (!maxProblems) return;

  for (let i = 5; i <= maxProblems; i += 5) {
    const tick = document.createElement("div");
    tick.className = "gaugeTick";
    const ratio = i / maxProblems;
    tick.style.left = `calc(${ratio * 100}% - 2px)`;
    container.appendChild(tick);
  }
}

function updateGauge() {
  if (!maxProblems) {
    document.getElementById("gaugeBar").style.width = "0%";
    document.getElementById("gaugeIcon").style.display = "none";
    return;
  }

  const ratio = Math.min(problemCount / maxProblems, 1);
  document.getElementById("gaugeBar").style.width = (ratio * 100) + "%";

  const icon = document.getElementById("gaugeIcon");
  const containerWidth = document.getElementById("gaugeContainer").offsetWidth;
  const iconWidth = icon.offsetWidth;

  if (problemCount === 0) {
    icon.style.display = "none";
    return;
  }
  icon.style.display = "block";

  const x = ratio * containerWidth - iconWidth;
  icon.style.transform = `translateX(${x}px)`;
}

/* ====== プレイヤー描画 ====== */
function adjustNameSize(nameDiv) {
  const maxHeight = 180;
  nameDiv.style.transform = "scaleY(1)";
  const actual = nameDiv.scrollHeight;

  if (actual > maxHeight) {
    const scale = (maxHeight / actual) * 0.85;
    nameDiv.style.transform = `scaleY(${scale})`;
  }
}

function calcTotal(player) {
  let total = 0;
  scoreItems.forEach(item => {
    const v = player.scores[item.name];
    const safe = Number.isFinite(v) ? v : 0;
    total += safe * item.weight;
  });
  return total;
}

function render() {
  const container = document.getElementById("players");
  container.innerHTML = "";

  players.forEach((p, idx) => {
    const div = document.createElement("div");
    div.className = "player";
    if (p.status === "out") div.classList.add("out");

    const nameDiv = document.createElement("div");
    nameDiv.className = "player-name";
    nameDiv.textContent = p.name;
    div.appendChild(nameDiv);
    requestAnimationFrame(() => adjustNameSize(nameDiv));

    const statusDiv = document.createElement("div");
    statusDiv.className = "player-status";

    if (winners.includes(idx)) {
      statusDiv.textContent = `${winners.indexOf(idx) + 1}位`;
      } else if (p.status === "out") {
        statusDiv.textContent = "脱落";
      } else if (getPreset() === "freeze" && p.freezeStop > 0) {
        statusDiv.textContent = `Stop ${p.freezeStop}`;
      } else {
        statusDiv.textContent = "";
    }
    div.appendChild(statusDiv);

    const scoreLine = document.createElement("div");
    scoreLine.className = "player-scoreline";

    const total = calcTotal(p);
    const wrong = Number.isFinite(p.scores["誤答"]) ? p.scores["誤答"] : 0;

    scoreLine.innerHTML = `
      <span class="player-score-total">${total}</span>
      <span class="player-score-dash"> - </span>
      <span class="player-score-wrong">${wrong}</span>
    `;
    div.appendChild(scoreLine);

    container.appendChild(div);
  });

  document.getElementById("problemCountDisplay").textContent =
    `問題数: ${problemCount}`;
}

/* ====== 設定表示 ====== */
function updateCurrentSettings() {
  document.getElementById("cs_rule").textContent      = getPreset() || "---";
  document.getElementById("cs_max").textContent       = maxProblems || "---";
  document.getElementById("cs_now").textContent       = problemCount;
  document.getElementById("cs_winScore").textContent  = winScore;
  document.getElementById("cs_winCount").textContent  = winCount;
  document.getElementById("cs_loseWrong").textContent = loseWrong;
}
  /* ====== Freeze 減衰 ====== */
function applyFreezeDecay() {
  if (getPreset() !== "freeze") return;
  players.forEach(p => {
    if (p.freezeStop > 0) p.freezeStop--;
  });
}

/* ====== 勝ち抜け判定 ====== */
function checkWinner(playerIndex) {
  const p = players[playerIndex];
  const total = calcTotal(p);

  if (total >= winScore && !winners.includes(playerIndex)) {
    winners.push(playerIndex);
    localStorage.setItem("winners", JSON.stringify(winners));

    const now = new Date().toLocaleTimeString();
    logs.push(`${now} ${p.name} が勝ち抜け（${winners.length}位）`);
    localStorage.setItem("logs", JSON.stringify(logs));
  }

  if (winners.length >= winCount) {
    finished = true;
  }
}

/* ====== 脱落判定 ====== */
function checkLose(playerIndex) {
  const p = players[playerIndex];
  const wrong = p.scores["誤答"] || 0;

  if (wrong >= loseWrong && p.status !== "out") {
    p.status = "out";

    const now = new Date().toLocaleTimeString();
    logs.push(`${now} ${p.name} が脱落`);
    localStorage.setItem("logs", JSON.stringify(logs));
  }
}
  
/* ====== 勝ち抜け設定モード判定 ====== */
function checkWinSettingMode() {
  if (winners.length >= winCount) return;

  const alive = players.filter((p, i) =>
    p.status !== "out" && !winners.includes(i)
  ).length;

  if (maxProblems && problemCount >= maxProblems && winners.length < winCount)
    winSettingMode = true;

  if (alive === winCount - winners.length)
    winSettingMode = true;

  document.getElementById("winMode").textContent =
    winSettingMode ? "勝ち抜け設定モード" : "";
}

/* ====== スコア処理 ====== */
function changeScore(playerIndex, itemName, delta) {
  if (finished || winSettingMode) return;

  const p = players[playerIndex];
  const preset = getPreset();

  if (preset === "freeze" && p.freezeStop > 0) return;

  const prevData = {
    type: "score",
    playerIndex,
    prevScores: JSON.parse(JSON.stringify(p.scores || {})),
    prevStatus: p.status,
    prevFreeze: p.freezeStop,
    prevWinners: [...winners],
    problemDelta: -1
  };
  history.push(prevData);

  if (typeof p.scores[itemName] !== "number") p.scores[itemName] = 0;
  p.scores[itemName] += delta;

  if (preset === "updown" && itemName === "誤答") {
    if (p.scores["誤答"] === 1) p.scores["正解"] = 0;
    if (p.scores["誤答"] === 2) p.status = "out";
  }

  if (preset === "freeze" && itemName === "誤答") {
    p.freezeStop = (p.scores["誤答"] || 0) + 1;
  }

  checkLose(playerIndex);
  checkWinner(playerIndex);

  problemCount++;
  applyFreezeDecay();
  updateGauge();
  render();
  updateCurrentSettings();
  checkWinSettingMode();

  const now = new Date().toLocaleTimeString();
  const seikai = p.scores["正解"] || 0;
  const gotou  = p.scores["誤答"] || 0;

  logs.push(`${now} ${p.name} ${itemName} +${delta} (${seikai}-${gotou})`);
  localStorage.setItem("logs", JSON.stringify(logs));
  localStorage.setItem("players", JSON.stringify(players));
  localStorage.setItem("problemCount", problemCount);
  localStorage.setItem("winners", JSON.stringify(winners));
}

/* ====== スルー ====== */
function noAnswer() {
  if (finished || winSettingMode) return;

  const prevData = {
    type: "noAnswer",
    prevFreezeAll: players.map(p => p.freezeStop),
    problemDelta: -1
  };
  history.push(prevData);

  problemCount++;
  applyFreezeDecay();
  updateGauge();
  render();
  updateCurrentSettings();
  checkWinSettingMode();

  const now = new Date().toLocaleTimeString();
  logs.push(`${now} スルー`);
  localStorage.setItem("logs", JSON.stringify(logs));

  localStorage.setItem("problemCount", problemCount);
}

/* ====== Undo ====== */
function undo() {
  if (finished || winSettingMode) return;

  const last = history.pop();
  if (!last) return;

  if (last.type === "score") {
    const p = players[last.playerIndex];
    p.scores = last.prevScores;
    p.status = last.prevStatus;
    p.freezeStop = last.prevFreeze;
    winners = last.prevWinners;
    problemCount += last.problemDelta;
  } else if (last.type === "noAnswer") {
    problemCount += last.problemDelta;
    players.forEach((p, i) => {
      p.freezeStop = last.prevFreezeAll[i];
    });
  }

  finished = false;

  updateGauge();
  render();
  updateCurrentSettings();
  checkWinSettingMode();

  const now = new Date().toLocaleTimeString();
  logs.push(`${now} Undo`);
  localStorage.setItem("logs", JSON.stringify(logs));

  localStorage.setItem("players", JSON.stringify(players));
  localStorage.setItem("problemCount", problemCount);
  localStorage.setItem("winners", JSON.stringify(winners));
}

  /* ====== キーボード操作 ====== */
document.addEventListener("keydown", (e) => {
  const code = e.code;
  const isNumpad = code.startsWith("Numpad");

  /* --- 勝ち抜け設定モード中：順位付け --- */
  if (winSettingMode) {
    if (!isNumpad) return;
    e.preventDefault();

    let index = null;
    if (code === "Numpad0") index = 9;
    else {
      const num = Number(code.replace("Numpad", ""));
      if (num >= 1 && num <= 9) index = num - 1;
    }

    if (index === null || index >= players.length) return;
    if (winners.includes(index)) return;

    winners.push(index);
    localStorage.setItem("winners", JSON.stringify(winners));

    if (winners.length >= winCount) {
      winSettingMode = false;
      finished = true;
    }

    render();
    updateCurrentSettings();
    checkWinSettingMode();
    return;
  }

  /* --- 通常モード --- */
  if (finished) return;

  if (isNumpad) {
    e.preventDefault();

    let index = null;
    if (code === "Numpad0") index = 9;
    else {
      const num = Number(code.replace("Numpad", ""));
      if (num >= 1 && num <= 9) index = num - 1;
    }

    if (index !== null && index < players.length) {
      const p = players[index];
      if (p.status !== "out" && !winners.includes(index) && p.freezeStop === 0) {
        if (e.ctrlKey) changeScore(index, "誤答", +1);
        else changeScore(index, "正解", +1);
      }
    }
    return;
  }

  if (code === "Insert") {
    e.preventDefault();
    noAnswer();
    return;
  }

  if (code === "Delete") {
    e.preventDefault();
    undo();
    return;
  }
});

/* ====== リセット ====== */
function resetAll() {
  const ok = window.confirm("全データをリセットします。よろしいですか？");
  if (!ok) return;

  players.forEach(p => {
    p.scores = {};
    p.status = "alive";
    p.freezeStop = 0;
  });

  history = [];
  logs = [];
  problemCount = 0;
  finished = false;
  winners = [];
  winSettingMode = false;

  localStorage.setItem("players", JSON.stringify(players));
  localStorage.setItem("problemCount", problemCount);
  localStorage.setItem("logs", JSON.stringify(logs));
  localStorage.setItem("winners", JSON.stringify(winners));

  updateGauge();
  render();
  updateCurrentSettings();
  checkWinSettingMode();

  /* ★ main 自身にも storage イベントを発火させる（画面更新のため） */
  window.dispatchEvent(new Event("storage"));
}

/* ====== localStorage 監視 ====== */
window.addEventListener("storage", () => {
  players      = JSON.parse(localStorage.getItem("players")      || "[]");
  scoreItems   = JSON.parse(localStorage.getItem("scoreItems")   || "[]");
  logs         = JSON.parse(localStorage.getItem("logs")         || "[]");
  problemCount = Number(localStorage.getItem("problemCount")     || 0);
  maxProblems  = Number(localStorage.getItem("maxProblems")      || 0);
  winScore     = Number(localStorage.getItem("winScore")         || 0);
  winCount     = Number(localStorage.getItem("winCount")         || 0);
  loseWrong    = Number(localStorage.getItem("loseWrong")        || 0);
  winners      = JSON.parse(localStorage.getItem("winners")      || "[]");

  finished = false;

  drawGaugeTicks();
  updateGauge();
  render();
  updateCurrentSettings();
  checkWinSettingMode();
});

/* ====== 初期描画 ====== */
drawGaugeTicks();
updateGauge();
render();
updateCurrentSettings();
checkWinSettingMode();
</script>

</body>
</html>
